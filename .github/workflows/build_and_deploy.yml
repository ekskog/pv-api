name: Build and Deploy PhotoVault API

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/ekskog/photovault-api

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 

      - name: Set Environment Variables
        run: |
          # Adding RUN_NUMBER to the tag to force K8s to pull a fresh image
          TAG="${{ github.run_number }}-${{ github.sha }}"
          echo "IMAGE_TAG=${{ env.IMAGE_NAME }}:$TAG" >> $GITHUB_ENV
          echo "SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)" >> $GITHUB_ENV

      - name: Check if app source code changed
        id: check_changes
        run: |
          if git diff --name-only HEAD~1 HEAD | grep -vE '^(\.github/|k8s/|README\.md|\.gitignore)' | grep -q .; then
            echo "APP_CHANGED=true" >> $GITHUB_ENV
          else
            echo "APP_CHANGED=false" >> $GITHUB_ENV
          fi

      - name: Set up Docker Buildx
        if: env.APP_CHANGED == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: env.APP_CHANGED == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.EK_GITHUB_PAT }}

      - name: Build and Push Docker Image
        if: env.APP_CHANGED == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          # FORCE NO CACHE to fix the corrupted package.json layer
          no-cache: true 
          tags: |
            ${{ env.IMAGE_TAG }}
            ${{ env.IMAGE_NAME }}:latest
      
      - name: Set Up KUBECONFIG
        run: |
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig.yaml
          echo "KUBECONFIG=$PWD/kubeconfig.yaml" >> $GITHUB_ENV
          kubectl cluster-info --kubeconfig=kubeconfig.yaml
                    
      - name: Create or Update Image Pull Secret
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password="${{ secrets.EK_GITHUB_PAT }}" \
            --namespace=photovault \
            --kubeconfig=kubeconfig.yaml \
            --dry-run=client -o yaml | kubectl apply -f - --kubeconfig=kubeconfig.yaml

      - name: Update Deployment Image
        run: |
          echo "ðŸš€ Deploying image: ${{ env.IMAGE_TAG }}"
          
          # Update API
          kubectl set image deployment/photovault-api \
            photovault-api=${{ env.IMAGE_TAG }} \
            --namespace=photovault --kubeconfig=kubeconfig.yaml
          
          # Update Worker (This ensures they use the same fresh build)
          kubectl set image deployment/pv-worker \
            pv-worker=${{ env.IMAGE_TAG }} \
            --namespace=photovault --kubeconfig=kubeconfig.yaml
          
          kubectl apply -f k8s/configmap.yaml --kubeconfig=kubeconfig.yaml --namespace=photovault
          kubectl apply -f k8s/secrets.yaml --kubeconfig=kubeconfig.yaml --namespace=photovault

      - name: Wait for Rollout
        run: |
          kubectl rollout status deployment/photovault-api --namespace=photovault --kubeconfig=kubeconfig.yaml --timeout=300s
          kubectl rollout status deployment/pv-worker --namespace=photovault --kubeconfig=kubeconfig.yaml --timeout=300s

      - name: Cleanup
        if: always()
        run: rm -f kubeconfig.yaml