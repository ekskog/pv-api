name: Build and Deploy PhotoVault API

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/ekskog/photovault-api

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need 2 commits to compare

      - name: Set Environment Variables
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV

      - name: Check if app source code changed
        id: check_changes
        run: |
          # Check if any files outside .github/ and k8s/ changed
          if git diff --name-only HEAD~1 HEAD | grep -vE '^(\.github/|k8s/|README\.md|\.gitignore)' | grep -q .; then
            echo "APP_CHANGED=true" >> $GITHUB_ENV
            echo "IMAGE_TAG=${{ env.IMAGE_NAME }}:$SHORT_SHA" >> $GITHUB_ENV
            echo "‚úÖ App source code changed - will build new image with tag: $SHORT_SHA"
          else
            echo "APP_CHANGED=false" >> $GITHUB_ENV
            # Get the latest existing image tag from registry
            LATEST_TAG=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/user/packages/container/photovault-api/versions" | \
              jq -r 'map(select(.metadata.container.tags | length > 0)) | .[0].metadata.container.tags[0] // "latest"')
            echo "IMAGE_TAG=${{ env.IMAGE_NAME }}:$LATEST_TAG" >> $GITHUB_ENV
            echo "‚ö° Only CI/CD or K8s config changed - reusing image: $LATEST_TAG"
          fi

      - name: Set up Docker Buildx
        if: env.APP_CHANGED == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: env.APP_CHANGED == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}  # Use GITHUB_TOKEN instead of PAT

      - name: Build and Push Docker Image
        if: env.APP_CHANGED == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.SHORT_SHA }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Set Up KUBECONFIG
        run: |
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig.yaml
          echo "KUBECONFIG=$PWD/kubeconfig.yaml" >> $GITHUB_ENV
          
          # Validate kubeconfig
          if [ ! -s kubeconfig.yaml ]; then
            echo "ERROR: kubeconfig.yaml is empty!"
            exit 1
          fi
          
          # Test connection
          kubectl cluster-info --kubeconfig=kubeconfig.yaml
                    
      - name: Create or Update Image Pull Secret
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password="${{ secrets.GITHUB_TOKEN }}" \
            --namespace=photovault \
            --kubeconfig=kubeconfig.yaml \
            --dry-run=client -o yaml | kubectl apply -f - --kubeconfig=kubeconfig.yaml

      - name: Update Deployment Image
        run: |
          if [ "${{ env.APP_CHANGED }}" == "true" ]; then
            echo "üöÄ Deploying NEW image: ${{ env.IMAGE_TAG }}"
          else
            echo "‚ôªÔ∏è Redeploying with existing image: ${{ env.IMAGE_TAG }}"
          fi
          
          # Use kubectl set image instead of sed for more reliable updates
          kubectl set image deployment/photovault-api \
            photovault-api=${{ env.IMAGE_TAG }} \
            --namespace=photovault \
            --kubeconfig=kubeconfig.yaml
          
          # Apply other manifests (they should be idempotent)
          kubectl apply -f k8s/configmap.yaml --kubeconfig=kubeconfig.yaml --namespace=photovault
          kubectl apply -f k8s/secrets.yaml --kubeconfig=kubeconfig.yaml --namespace=photovault

      - name: Wait for Rollout
        run: |
          kubectl rollout status deployment/photovault-api \
            --namespace=photovault \
            --kubeconfig=kubeconfig.yaml \
            --timeout=300s

      - name: Verify Deployment
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployment photovault-api -n photovault --kubeconfig=kubeconfig.yaml
          echo "=== Pod Status ==="
          kubectl get pods -l app=photovault-api -n photovault --kubeconfig=kubeconfig.yaml
          echo "=== Recent Events ==="
          kubectl get events --sort-by=.metadata.creationTimestamp -n photovault --kubeconfig=kubeconfig.yaml | tail -10

      - name: Cleanup
        if: always()
        run: |
          rm -f kubeconfig.yaml